/*******************************************************************************
 * Copyright (c) 2015-2023 Matt Tropiano
 * This program and the accompanying materials are made available under the 
 * terms of the GNU Lesser Public License v2.1 which accompanies this 
 * distribution, and is available at
 * http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
 ******************************************************************************/
package net.mtrop.doom.map;

import java.io.IOException;
import java.io.Reader;
import java.io.Writer;

import net.mtrop.doom.map.udmf.UDMFObject;
import net.mtrop.doom.map.udmf.UDMFReader;
import net.mtrop.doom.map.udmf.UDMFWriter;
import net.mtrop.doom.map.udmf.attributes.UDMFGlobalAttributes;
import net.mtrop.doom.map.udmf.listener.UDMFTypeListener;
import net.mtrop.doom.object.TextObject;

/**
 * A map that contains full UDMF map data.
 * @author Matthew Tropiano
 */
public class UDMFMap extends CommonMap<UDMFObject, UDMFObject, UDMFObject, UDMFObject, UDMFObject> implements TextObject
{
	/** Type name: Vertex. */
	public static final String VERTEX = "vertex";
	/** Type name: Linedef. */
	public static final String LINEDEF = "linedef";
	/** Type name: Sidedef. */
	public static final String SIDEDEF = "sidedef";
	/** Type name: Sector. */
	public static final String SECTOR = "sector";
	/** Type name: Thing. */
	public static final String THING = "thing";
	
	/** The namespace for this UDMF map. */
	private String namespace;
	
	/**
	 * Creates a blank map.
	 */
	public UDMFMap()
	{
		super();
		this.namespace = null;
	}
	
	@Override
	public void clear()
	{
		super.clear();
		setNamespace(null);
	}
	
	/**
	 * Gets this UDMF namespace.
	 * @return the namespace for this UDMF map.
	 */
	public String getNamespace()
	{
		return namespace;
	}
	
	/**
	 * Sets the UDMF namespace for this map.
	 * @param namespace the new namespace.
	 */
	public void setNamespace(String namespace)
	{
		this.namespace = namespace;
	}

	@Override
	public void readText(Reader reader) throws IOException
	{
		clear();
		final IOException[] exception = new IOException[1];
		UDMFReader.readData(reader, new UDMFTypeListener(){

			@Override
			public void onParseError(String error)
			{
				exception[0] = new IOException(error);
			}

			@Override
			public void onGlobalAttribute(String name, Object value)
			{
				if (name.equals(UDMFGlobalAttributes.ATTRIB_NAMESPACE))
					setNamespace(String.valueOf(value));
			}

			@Override
			public void onType(String type, UDMFObject object)
			{
				switch (type)
				{
					case UDMFMap.VERTEX:
						addVertex(object);
						break;
					case UDMFMap.LINEDEF:
						addLinedef(object);
						break;
					case UDMFMap.SIDEDEF:
						addSidedef(object);
						break;
					case UDMFMap.SECTOR:
						addSector(object);
						break;
					case UDMFMap.THING:
						addThing(object);
						break;
				}
			}
		});

		if (exception[0] != null)
			throw exception[0];
	}

	@Override
	public void writeText(Writer writer) throws IOException
	{
		writer.append("// Generated by Doom Struct").append('\n').append('\n');
		UDMFWriter.writeField(UDMFGlobalAttributes.ATTRIB_NAMESPACE, namespace, writer, "");
		for (int i = 0; i < getThingCount(); i++)
			UDMFWriter.writeObject(getThing(i), writer, THING, i);
		for (int i = 0; i < getVertexCount(); i++)
			UDMFWriter.writeObject(getVertex(i), writer, VERTEX, i);
		for (int i = 0; i < getLinedefCount(); i++)
			UDMFWriter.writeObject(getLinedef(i), writer, LINEDEF, i);
		for (int i = 0; i < getSidedefCount(); i++)
			UDMFWriter.writeObject(getSidedef(i), writer, SIDEDEF, i);
		for (int i = 0; i < getSectorCount(); i++)
			UDMFWriter.writeObject(getSector(i), writer, SECTOR, i);
	}
	
}
